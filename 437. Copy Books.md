### 题目
https://www.lintcode.com/problem/437/

### 分类
* 划分型动态规划 (0到n + 1)

### 题目特点
求最大最小值：k个抄写员**最少**需要多少时间抄写完所有的书（每个抄写员的抄写速度一样，每个抄写员同时开始，所需的时间就是最慢的抄写员完成的时间） [Dynamic Programming](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Dynamic-Programming)

### 思路1
0. 输入一个数组pages，元素值代表每本书的页数，即抄写时间，数组的长度n代表书的数量，k代表抄写员数量

1. 确定状态
    * 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么
        * 类似于解数学题中，x，y，z代表什么  
    * 确定状态需要两个意识
        * 最后一步
        * 子问题
    * 根据下面的分析
        * 设状态f[x][y] = **x个抄写员最少需要多少时间抄写完第0... y - 1本书，即前y本书**

#### 最后一步
* 关注最优策略中最后一个抄写员k
* 如果抄写员k抄写第j ... n - 1本书
* 那么抄写员k需要时间pages[j] + ... + pages[n - 1]
* 需要知道前面的k - 1个抄写员**最少**需要多少时间抄写完0 ... j - 1本书，即前j本书

#### 子问题
* **k - 1个抄写员最少需要多少时间抄写完第0 ... j - 1本书，即前j本书**
* 原问题是**k个抄写员最少需要多少时间抄写完第0... n - 1本书，即前n本书**
* 我们将原问题转化成了一个子问题，而且规模更小：0 ... j - 1

2. 转移方程
* f[x][y] = min0 <= j <= y {max{f[x - 1][j], pages[j] + ... + pages[y - 1]}}
    * f[x][y] = **x个抄写员最少需要多少时间抄写完第0... y - 1本书，即前y本书**
    * f[x - 1][j] = **x - 1个抄写员最少需要多少时间抄写完第0 ... j - 1本书，即前j本书**
    * pages[j] + ... + pages[y - 1] = 第x个抄写员抄写第j ... y - 1本书的时间
* 举例分析
```
f[2][1]: 两个抄写员抄写一本书
max{f[1][0], pages[0]} = 第一个抄写员啥也不干，第二个抄写员抄，花多少时间
max{f[1][1], 0} = 第一个抄写员抄，第二个抄写员啥也不干，花多少时间
min{max{f[1][0], pages[0]}, max{f[1][1], 0}} = 两个抄写员抄写一本书最少花多少时间
f[2][1] = min{max{f[1][0], pages[0]}, max{f[1][1], 0}}

f[2][2]: 两个抄写员抄写两本书
max{f[1][0], pages[0] + pages[1]} = 第一个抄写员啥也不干，第二个抄写员抄两本书，花多少时间
max{f[1][1], pages[1]} = 第一个抄写员抄一本书，第二个抄写员一本书，花多少时间
max{f[1][2], 0} = 第一个抄写员抄两本书，第二个抄写员啥也不干，花多少时间
min{max{f[1][0], pages[0] + pages[1]}, max{f[1][1], pages[1]}, max{f[1][2], 0}} = 两个抄写员抄写两本书最少花多少时间
f[2][2] = min{max{f[1][0], pages[0] + pages[1]}, max{f[1][1], pages[1]}, max{f[1][2], 0}}
...
```

3. 初始条件和边界情况
* 初始条件
    * f[0][0] = 0，0个抄写员需要0时间抄写0本书
    * f[k][0] = 0，k个抄写员需要0时间抄写0本书
* 边界情况
    * 无

4. 计算顺序
* **x个抄写员最少需要多少时间抄写完第0... y - 1本书，即前y本书**：f[x][y] = min0 <= j <= y {max{f[x - 1][j], pages[j] + ... + pages[y - 1]}}
* 初始条件：f[0][0] = 0，f[k][0] = 0
* 然后计算f[0][0]，f[0][1]，...，f[0][n]，f[1][0]，f[1][1]，...，f[1][n]，...，f[k][n]，这里按照二维数组从小到大一行一行扫描的顺序，由于每个结果都存在了二维数组中，就能解决重复计算
* 当我们计算到f[x][y]时，f[0][0]，...，f[x - 1][n]都已经得到结果了
    * 没有重复计算，**解决了重复计算的问题**
    * 二维数组的中每个元素代表一种情况，都要计算，并都使用前面的结果计算
    * 计算每个元素时，都要遍历前y本书，找到抄写时间最短的情况（注意这里可能会导致O(n)，如答案1的解法，会导致总时间复杂度 = O(k * n^3)），即等差数列求和(0 + (n - 1)) * n / 2，每一行，即对于不同的抄写员的数量x，都计算了O(n^2)步
    * 总时间复杂度 = O(k * n^2)

### 答案1（超时，当前解决方案的时间复杂度是O(k * n^3)）
```
public int copyBooks(int[] pages, int k) {
    int n = pages.length;
    if (n == 0) {
        return 0;
    }
    // 最快速度是一人抄一本
    if (k > n) {
        Arrays.sort(pages);
        return pages[n - 1];
    }
    int[][] f = new int[k + 1][n + 1];
    f[0][0] = 0; // 初始条件
    // 0个抄写员就是无限时间
    for (int j = 1; j <= n; j++) {
        f[0][j] = Integer.MAX_VALUE;
    }
    // 遍历二维数组的每个元素
    for (int i = 1; i <= k; i++) {
        // f[k][0] = 0; 初始条件
        f[i][0] = 0;
        for (int j = 1; j <= n; j++) {
            f[i][j] = Integer.MAX_VALUE;
            // 计算每个元素时，都要遍历前j本书
            for (int l = 0; l <= j; l++) {
                int sum = 0;
                for (int m = l; m < j; m++) {
                    sum = sum + pages[m];
                }
                f[i][j] = Math.min(f[i][j], Math.max(f[i - 1][l], sum));
            }
        }
    }
    return f[k][n];
}
```

### 答案2（观察规律，优化求和部分）
```
public int copyBooks(int[] pages, int k) {
    int n = pages.length;
    if (n == 0) {
        return 0;
    }
    // 最快速度是一人抄一本
    if (k > n) {
        Arrays.sort(pages);
        return pages[n - 1];
    }
    int[][] f = new int[k + 1][n + 1];
    f[0][0] = 0; // 初始条件
    // 0个抄写员就是无限时间
    for (int j = 1; j <= n; j++) {
        f[0][j] = Integer.MAX_VALUE;
    }
    // 遍历二维数组的每个元素
    for (int i = 1; i <= k; i++) {
        // f[k][0] = 0; 初始条件
        f[i][0] = 0;
        for (int j = 1; j <= n; j++) {
            f[i][j] = Integer.MAX_VALUE;
            // 计算每个元素时，都要遍历前j本书
            // 第一次求0 ... j - 1的和
            // 第二次求1 ... j - 1的和
            // ...
            // 第j次求j - 1 ... j - 1的和
            // 观察规律，这个遍历应该倒着求和，这样可以减少重复计算
            int sum = 0;
            for (int l = j; l >= 0; l--) {
                f[i][j] = Math.min(f[i][j], Math.max(f[i - 1][l], sum));
                if (l > 0) {
                    sum = sum + pages[l - 1];
                }
            }
        }
    }
    return f[k][n];
}
```

### 复杂度
* 时间复杂度：(k * n^2)
* 空间复杂度：(k * n)
